# Web

## Lectures
<details><summary>Introduction</summary><div class="border embed-responsive embed-responsive-16by9" data-video=""><iframe allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="" class="embed-responsive-item" src="https://www.youtube.com/embed/BB7xPefB8og?modestbranding=0&amp;rel=0&amp;showinfo=0"></iframe></div>

<ul>
  <li data-marker="*">In this track, we’ll write programs that can run on the internet. We’ll first learn about the basics of the internet and how it works, and then dive into the languages of the internet, from HTML and CSS to JavaScript to frameworks in Python and SQL that can turn a webpage into an application.</li>
</ul></details>

<details><summary>HTTP</summary><div class="border embed-responsive embed-responsive-16by9" data-video=""><iframe allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="" class="embed-responsive-item" src="https://www.youtube.com/embed/iSFEjQRulf0?modestbranding=0&amp;rel=0&amp;showinfo=0"></iframe></div>

<ul>
  <li data-marker="*">Computers talk to each other across the network by sending and receiving messages. At the most basic level, there are standard protocols, or rules to follow, for sending and receiving messages. In the context of the internet, the standard protocol is TCP/IP, Transmission Control Protocol and Internet Protocol. We can think of this at a high-level as sending a letter in the mail, with an address for the recipient and the address of the sender. On the internet, computers have IP addresses, usually in the format <code class="language-plaintext highlighter-rouge">#.#.#.#</code>, so our digital envelope might include <code class="language-plaintext highlighter-rouge">1.2.3.4</code> for the address of the computer we want to message, and our own address <code class="language-plaintext highlighter-rouge">5.6.7.8</code>, so that we can get a response.</li>
  <li data-marker="*">[2:16] With four numbers of one byte each, an IP address is 32 bits, which only allows us to count up to about 4 billion. It turns out that we now have more devices than 32 bits will support, and so in addition to IPv4, the protocol with 32-bit addresses, we also have IPv6, a protocol with 128-bit addresses.</li>
  <li data-marker="*">[4:10] In addition to the address of the recipient, we also specify a port number, or a number assigned to a particular service or type of message, like emails, webpages, or files. This way, the recipient computer can process incoming messages with the right program. So our envelope might say <code class="language-plaintext highlighter-rouge">1.2.3.4:80</code>.</li>
  <li data-marker="*">[5:50] But when we visit a website, we probably type in something like <code class="language-plaintext highlighter-rouge">example.com</code>, and it turns out that there’s something called DNS, Domain Name System, which maps domain names to IP addresses of the servers that can respond for that domain.</li>
  <li data-marker="*">[7:40] And we might notice URLs are the form <code class="language-plaintext highlighter-rouge">http://www.example.com</code>, and HTTP is short for another protocol, Hypertext Transfer Protocol, which essentially describe the format of the contents inside each digital envelope. The content of a request in HTTP might look like:
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>GET / HTTP/1.1
Host: www.example.com
...
</code></pre></div>    </div>
    <ul>
      <li data-marker="*">The first parameter, <code class="language-plaintext highlighter-rouge">GET</code>, specifies what the action we’re trying to do here, which is just getting something. The next one, <code class="language-plaintext highlighter-rouge">/</code>, stands for the root, or the top-most directory. Finally, <code class="language-plaintext highlighter-rouge">HTTP/1.1</code> is the version of protocol we’re asking to use. We also specify the host, or the website, since the same server might be able to handle multiple, and there’s also additional information in a request that are less important.</li>
    </ul>
  </li>
  <li data-marker="*">[10:15] The response we get back might look like:
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HTTP/1.1 200 OK
Content-Type: text/html
...
</code></pre></div>    </div>
    <ul>
      <li data-marker="*">Here we get an HTTP status code of 200, which means “OK”, and then a line describing the type of content. HTML, Hypertext Markup Language, is a format that webpages use to markup content. Finally, we’ll get the actual data for the page.</li>
    </ul>
  </li>
  <li data-marker="*">[11:40] Other common status codes include 404, for a page not found, and 500 for an internal server error, where the server itself had an error trying to respond.</li>
  <li data-marker="*">[13:05] We can open Google Chrome, and open the Developer Tools panel. In the Network tab, we can load a site, and see lots of requests. At the very top, we can see the original request for <code class="language-plaintext highlighter-rouge">google.com</code>, and we’ll see the Request Headers that we sent, and the Response Headers we got back. In fact, the first response we got back was <code class="language-plaintext highlighter-rouge">HTTP/1.1 301 Moved Permanently</code>, to <code class="language-plaintext highlighter-rouge">http://www.google.com</code>, since by convention URLs for websites start with <code class="language-plaintext highlighter-rouge">www</code>. Next, we get redirected to <code class="language-plaintext highlighter-rouge">https://www.google.com</code>, with the more secure, encrypted version of HTTP. In this response, we finally get a <code class="language-plaintext highlighter-rouge">200 OK</code> code and some content to load the page. Later, we’ll be writing our own server programs that return these codes and content in response to requests from browsers.</li>
</ul></details>

<details><summary>HTML</summary><div class="border embed-responsive embed-responsive-16by9" data-video=""><iframe allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="" class="embed-responsive-item" src="https://www.youtube.com/embed/78wdlyzrKOA?modestbranding=0&amp;rel=0&amp;showinfo=0"></iframe></div>

<ul>
  <li data-marker="*">Now that our computers can communicate over the internet, we can take a closer look at the actual data we get back. In Chrome, we can go to View &gt; Developer &gt; View Source, to see the HTML, Hypertext Markup Language, that makes up the text-based content of a webpage.</li>
  <li data-marker="*">[1:30] We’ll look at a simple HTML page, where we first declare to the browser of the version and format of the page. Then, we have a tag, <code class="language-plaintext highlighter-rouge">&lt;html&gt;</code>, which starts the HTML content. Generally, HTML is made up of lots of nested tags that map to a tree structure, with opening tags and closing tags that determine the structure of the page. Next we have the <code class="language-plaintext highlighter-rouge">&lt;head&gt;</code> tag, which includes metadata, data about the page, such as the <code class="language-plaintext highlighter-rouge">&lt;title&gt;</code> tag inside that defines what the title of the webpage will be, as displayed in the tab of the browser. After, we have the <code class="language-plaintext highlighter-rouge">&lt;body&gt;</code> tag, which contains the visible content displayed by the browser.</li>
  <li data-marker="*">[6:00] In the CS50 IDE, we can start by writing this code in a file called <code class="language-plaintext highlighter-rouge">index.html</code>. And the CS50 IDE has a built-in server we can use. In the terminal, we can run <code class="language-plaintext highlighter-rouge">http-server</code>, and there will be a URL for our IDE’s server that we can open. Then, we’ll see the files in our IDE, and we can open <code class="language-plaintext highlighter-rouge">index.html</code>. We can change our file, save, and refresh to see what it looks like.</li>
  <li data-marker="*">[10:20] We take a look at an example where we use an <code class="language-plaintext highlighter-rouge">&lt;img&gt;</code> tag to display an image. Here, we add attributes, or additional parameters to the tag, like <code class="language-plaintext highlighter-rouge">src="cat.jpg"</code> to indicate that the source of the image is a file called <code class="language-plaintext highlighter-rouge">cat.jpg</code>, and <code class="language-plaintext highlighter-rouge">alt=""</code> to indicate alternative text for the image. And the <code class="language-plaintext highlighter-rouge">&lt;img&gt;</code> tag doesn’t have a closing tag, since it doesn’t make sense for there to be other tags inside the image.</li>
  <li data-marker="*">[13:30] We add links to go between pages with the <code class="language-plaintext highlighter-rouge">&lt;a&gt;</code>, or anchor, tag. Notice that we can have any text for any URL for our link, so we should pay attention to the URL we end up at.</li>
  <li data-marker="*">[18:00] We can add additional elements, like paragraphs with the <code class="language-plaintext highlighter-rouge">&lt;p&gt;</code> tag, headings with <code class="language-plaintext highlighter-rouge">&lt;h1&gt;</code> or <code class="language-plaintext highlighter-rouge">&lt;h2&gt;</code>, or tables with <code class="language-plaintext highlighter-rouge">&lt;table&gt;</code>.</li>
  <li data-marker="*">[22:35] We’ll add aesthetic styling like borders and colors later, but we can think about HTML as describing the structure of the content of our webpage.</li>
  <li data-marker="*">[22:55] We’ll add a <code class="language-plaintext highlighter-rouge">&lt;form&gt;</code> element with some <code class="language-plaintext highlighter-rouge">&lt;input&gt;</code> elements where we can get some information from the user. Finally, we can redirect ourself to Google’s search page for whatever we typed in, by using <code class="language-plaintext highlighter-rouge">https://www.google.com/search</code>. We noticed that <code class="language-plaintext highlighter-rouge">https://www.google.com/search?q=cats</code> takes us to a search page for cats, and the <code class="language-plaintext highlighter-rouge">?</code> indicates some HTTP GET parameters, where here we have a <code class="language-plaintext highlighter-rouge">q</code>, or query, parameter, with the value <code class="language-plaintext highlighter-rouge">cats</code>. So our form can have an <code class="language-plaintext highlighter-rouge">action</code> that submits our text input with <code class="language-plaintext highlighter-rouge">name="q"</code>, to <code class="language-plaintext highlighter-rouge">https://www.google.com/search</code>.</li>
  <li data-marker="*">[29:35] There are so many more HTML elements. We can likely find an HTML tag that lets us add a particular feature, just by searching Google for relevant documentation.</li>
</ul></details>

<details><summary>CSS</summary><div class="border embed-responsive embed-responsive-16by9" data-video=""><iframe allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="" class="embed-responsive-item" src="https://www.youtube.com/embed/g7nZFp2zSJ4?modestbranding=0&amp;rel=0&amp;showinfo=0"></iframe></div>

<ul>
  <li data-marker="*">To style webpages, we’ll use another language, CSS, Cascading Style Sheets.</li>
  <li data-marker="*">[0:40] First, in our HTML, we’ll need to add a <code class="language-plaintext highlighter-rouge">style</code> attribute to a tag, and set the value to something like <code class="language-plaintext highlighter-rouge">style="color: blue;"</code>. The key-value pairs in the style will change how the browser displays the element. In fact, we can add a style to the <code class="language-plaintext highlighter-rouge">&lt;body&gt;</code>, and all the elements inside the body will inherit the style unless they specifically have a different style.</li>
  <li data-marker="*">[5:20] We can also change the alignment, like centering or right-aligning text, or the font size. We can add multiple properties by separating them with semicolons.</li>
  <li data-marker="*">[8:40] We might have multiple elements of the same type, like <code class="language-plaintext highlighter-rouge">&lt;h1&gt;</code>, and we can add a common set of styles in the <code class="language-plaintext highlighter-rouge">&lt;head&gt;</code> element with the <code class="language-plaintext highlighter-rouge">&lt;style&gt;</code> tag. In that tag, we can specify that all <code class="language-plaintext highlighter-rouge">h1</code> elements share some set of styles.</li>
  <li data-marker="*">[14:00] If we want set the same styles to multiple types of elements, we can add classes, which we can think of as names, to any number and type of element. We’ll do this by adding the <code class="language-plaintext highlighter-rouge">class="title"</code> attribute, with a class name of our choosing, to elements we want to style the same way. Then, in our CSS we can select all elements with the class with <code class="language-plaintext highlighter-rouge">.title</code>.</li>
  <li data-marker="*">[18:25] We can create another class, and even give the same element multiple classes with <code class="language-plaintext highlighter-rouge">class="title green"</code>, and the styles for both will apply.</li>
  <li data-marker="*">[20:40] We can include CSS in a separate file, like <code class="language-plaintext highlighter-rouge">styles.css</code>, so all of our webpages can share the same styles. We’ll use a new tag, <code class="language-plaintext highlighter-rouge">&lt;link&gt;</code>, to link a file to our HTML page. And we can include many different CSS files, each of which having some subset of styles.</li>
  <li data-marker="*">[24:00] With CSS, we can also style tables in HTML by selecting the <code class="language-plaintext highlighter-rouge">table</code>, <code class="language-plaintext highlighter-rouge">tr</code>, and <code class="language-plaintext highlighter-rouge">td</code> classes. By looking at CSS documentation online, we can figure out what styles will give us the border styles we want.</li>
  <li data-marker="*">[27:40] We can add padding, or spacing, within each table data cell. And we can select the first row by adding a class like <code class="language-plaintext highlighter-rouge">header</code>, or use a special table header cell element <code class="language-plaintext highlighter-rouge">&lt;th&gt;</code> that we can select precisely.</li>
  <li data-marker="*">[31:05] It turns out that there are lots of CSS libraries, written by other people, that will include styles for common elements that can quickly apply a theme or aesthetic to our HTML. Bootstrap is one such popular library, and its documentation will include a <code class="language-plaintext highlighter-rouge">&lt;link&gt;</code> element we can add, such that our page will use Boostrap’s CSS files. The documentation will also show us various components we can use, and classes we can use to style them easily. A <code class="language-plaintext highlighter-rouge">&lt;div&gt;</code> element in HTML is like a generic container or section, so we’ll see that commonly used for elements that don’t have a more semantic HTML tag.</li>
</ul></details>

<details><summary>JavaScript</summary><div class="border embed-responsive embed-responsive-16by9" data-video=""><iframe allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="" class="embed-responsive-item" src="https://www.youtube.com/embed/WzfPjOYmjxg?modestbranding=0&amp;rel=0&amp;showinfo=0"></iframe></div>

<ul>
  <li data-marker="*">To build a more interactive website, we’ll need a programming language that will allow us to run code on the browser that changes how it behaves with our webpage, beyond just the content and style. The language that we’ll use is JavaScript, a language that browsers can interpret and run, with syntax similar to that of C.</li>
  <li data-marker="*">[0:35] We take a look at syntax for declaring and changing variables, conditions, loops, and functions.</li>
  <li data-marker="*">[5:00] A simple webpage has elements that we can represent as a graphical tree, where each nested element is a child of a node in the tree. This is called the Document Object Model, and JavaScript can manipulate, or change this, without having to refresh the page.</li>
  <li data-marker="*">[7:15] We’ll add JavaScript to our page with a <code class="language-plaintext highlighter-rouge">&lt;script&gt;</code> tag inside our <code class="language-plaintext highlighter-rouge">&lt;head&gt;</code> tag. We can call a built-in function, <code class="language-plaintext highlighter-rouge">alert()</code>, to show an alert on our page. After we save our file, we can run a server in our IDE with <code class="language-plaintext highlighter-rouge">http-server</code>, and see our page.</li>
  <li data-marker="*">[9:20] We can add a form, and have our form call a function and <code class="language-plaintext highlighter-rouge">return false;</code> to stop any default behavior after our function is called.</li>
  <li data-marker="*">[12:00] Our form can have a text field, and our JavaScript button can get its value. Fist, we need to add an ID to our element with an attribute to the element, like <code class="language-plaintext highlighter-rouge">id="name"</code>. And in Javascript, we can use <code class="language-plaintext highlighter-rouge">document.querySelector('#name')</code> to get that element by its id.</li>
  <li data-marker="*">[17:25] We can change our alert to display something else with a condition.</li>
  <li data-marker="*">[18:45] Instead of just reading the content of the DOM, we can also change the contents of elements by setting their <code class="language-plaintext highlighter-rouge">innerHTML</code> property, after selecting them with <code class="language-plaintext highlighter-rouge">document.querySelector</code>.</li>
  <li data-marker="*">[22:00] We’ll look at another example that has a counter, or a variable that we can increment by pressing a button.</li>
  <li data-marker="*">[24:25] It turns out that we can even change these variables or call these functions in our browser, with View &gt; Developer &gt; Developer Tools in Chrome. In the Console tab, we can type in JavaScript code, and it will run in our page. If our JavaScript code has errors, those errors will also show up in the console.</li>
  <li data-marker="*">[26:00] We can dynamically change the style of the page. We’ll create three buttons, each with a unique <code class="language-plaintext highlighter-rouge">id</code>. And in our script tag, we’ll select each button, and we’ll set their <code class="language-plaintext highlighter-rouge">onclick</code> property to a function that our browser will call when the button is clicked. We can create an anonymous function, or a function with no name, directly with <code class="language-plaintext highlighter-rouge">function() { ... }</code>, instead of defining it separately first. And in our function, we can select the <code class="language-plaintext highlighter-rouge">body</code> tag by type since there’s only one of them on our page, and set the <code class="language-plaintext highlighter-rouge">style.backgroundColor</code> property to a color.</li>
  <li data-marker="*">[30:25] It turns out that we can’t add the <code class="language-plaintext highlighter-rouge">onclick</code> function in the beginning of our JavaScript code, since our browser interprets the code from top to bottom, and our code can’t find the buttons. There are a few ways to solve this problem, but for now we can simply move our <code class="language-plaintext highlighter-rouge">script</code> tag to the end of our <code class="language-plaintext highlighter-rouge">body</code> tag.</li>
  <li data-marker="*">[33:55] The <code class="language-plaintext highlighter-rouge">onclick</code> function is an event handler, or a function that is called when an event happens. There are many such events that we can listen for, like a change to the selected option in a dropdown menu. We’ll look at another example, where we add <code class="language-plaintext highlighter-rouge">onChange</code> to a <code class="language-plaintext highlighter-rouge">&lt;select&gt;</code> element. Here, inside our event handler function, we can use <code class="language-plaintext highlighter-rouge">this.value()</code> to get the value of the option that was just selected. We can think of <code class="language-plaintext highlighter-rouge">this</code> as a special variable that contains some kind of context for how a function is called. In this case, <code class="language-plaintext highlighter-rouge">this</code> is the event that triggered our event handler.</li>
  <li data-marker="*">[39:20] We can update our page periodically with <code class="language-plaintext highlighter-rouge">window.setInterval</code>, which calls a function for us at some interval of time. We’ll create a function, <code class="language-plaintext highlighter-rouge">blink()</code>, that will change the <code class="language-plaintext highlighter-rouge">body</code>’s visibility to be either <code class="language-plaintext highlighter-rouge">visible</code> or <code class="language-plaintext highlighter-rouge">hidden</code>.</li>
  <li data-marker="*">[43:10] We can also create a separate file like <code class="language-plaintext highlighter-rouge">blink.js</code>, where we only have our JavaScript code, and include it in our HTML file with <code class="language-plaintext highlighter-rouge">&lt;script src="blink.js"&gt;&lt;/script&gt;</code>.</li>
  <li data-marker="*">[44:45] Finally, we can ask the browser to give the user’s location to our JavaScript code, with <code class="language-plaintext highlighter-rouge">navigator.geolocation.getCurrentPosition</code>. The argument we pass in is a callback function, or a function that will be called by the browser when the <code class="language-plaintext highlighter-rouge">getCurrentPosition</code> finishes running. Inside our function, we’ll just write the coordinates we get to the page.</li>
  <li data-marker="*">[47:05] With JavaScript, we can read and write to the DOM, and take advantage of even more features that browsers provide.</li>
</ul></details>

<details><summary>Homepage</summary><div class="border embed-responsive embed-responsive-16by9" data-video=""><iframe allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="" class="embed-responsive-item" src="https://www.youtube.com/embed/sEVlPyywlfc?modestbranding=0&amp;rel=0&amp;showinfo=0"></iframe></div>

<ul>
  <li data-marker="*">Our first assignment will be to create a homepage of our choice using HTML, CSS, and JavaScript.</li>
  <li data-marker="*">We’ll create four different pages in HTML, each linked to one another somehow. Recall that we can use the <code class="language-plaintext highlighter-rouge">&lt;a&gt;</code> tag, with the link to another file in our IDE.</li>
  <li data-marker="*">We’ll also use at least five different CSS selectors, for five different types elements, classes, or IDs. And we’ll want to use at least five different properties overall to style our page, and documentation online will help us find what we’re looking for. We’ll also use the Bootstrap library to style at least one of our components, so we don’t have to write the CSS ourselves for that.</li>
  <li data-marker="*">Finally, after we’ve written the content for our pages and styled them, we’ll use JavaScript to make our page interactive somehow, through alerts, buttons, dropdowns, forms, intervals, or even more.</li>
  <li data-marker="*">Be as creative as you’d like!</li>
</ul></details>

## Shorts
<ol>
  <li><a href="https://www.youtube.com/watch?v=04GztBlVo_s">Internet Primer</a></li>
  <li><a href="https://www.youtube.com/watch?v=A1g9SokDJSU">IP</a></li>
  <li><a href="https://www.youtube.com/watch?v=GP7uvI_6uas">TCP</a></li>
  <li><a href="https://www.youtube.com/watch?v=4axL8Gfw2nI">HTTP</a></li>
  <li><a href="https://www.youtube.com/watch?v=YK78KhMf7bs">HTML</a></li>
  <li><a href="https://www.youtube.com/watch?v=Ub3FKU21ubk">CSS</a></li>
  <li><a href="https://www.youtube.com/watch?v=Z93IaNfavZw">JavaScript</a></li>
</ol>

## References
<ul>
  <li data-marker="*"><a href="\ap\assets\pdfs\internet_basics.pdf">Internet Basics</a></li>
  <li data-marker="*"><a href="\ap\assets\pdfs\ip_addresses.pdf">IP Addresses</a></li>
  <li data-marker="*"><a href="\ap\assets\pdfs\tcp_and_ip.pdf">TCP and IP</a></li>
  <li data-marker="*"><a href="\ap\assets\pdfs\dns_and_dhcp.pdf">DNS and DHCP</a></li>
  <li data-marker="*"><a href="\ap\assets\pdfs\http.pdf">HTTP</a></li>
  <li data-marker="*"><a href="\ap\assets\pdfs\html.pdf">HTML</a></li>
  <li data-marker="*"><a href="\ap\assets\pdfs\css.pdf">CSS</a></li>
  <li data-marker="*"><a href="\ap\assets\pdfs\javascript.pdf">JavaScript</a></li>
</ul>

## Problems
* [Homepage](homepage)

---
---

## Lectures
<details><summary>Flask</summary><div class="border embed-responsive embed-responsive-16by9" data-video=""><iframe allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="" class="embed-responsive-item" src="https://www.youtube.com/embed/GhB6Q7KC-SM?modestbranding=0&amp;rel=0&amp;showinfo=0"></iframe></div>

<ul>
  <li data-marker="*">So far, we’ve learned how to write webpages that are saved as a file and returned by an HTTP server. But we can also have web servers, or applications, that generate content dynamically before returning it as a response.</li>
  <li data-marker="*">[1:00] We’ll use a framework in Python called Flask, which allows us to write a web server with many features. We’ll create a new folder in our IDE, called <code class="language-plaintext highlighter-rouge">hello/</code>, and create a new file called <code class="language-plaintext highlighter-rouge">application.py</code>. By reading the documentation and experimenting, we can write our first Flask application which returns something for the <code class="language-plaintext highlighter-rouge">/</code> route. And in our terminal, we can <code class="language-plaintext highlighter-rouge">cd</code> into our folder and run <code class="language-plaintext highlighter-rouge">flask run</code>, which will find our <code class="language-plaintext highlighter-rouge">application.py</code> file and run it. We’ll open the URL, and see our returned string.</li>
  <li data-marker="*">[4:10] We’ll add another route, <code class="language-plaintext highlighter-rouge">/goodbye</code>, and a function that returns different content. We can return any content we want in our routes.</li>
  <li data-marker="*">[6:00] It turns out that Flask allows us to use template files, or files with HTML that are like format strings, with some parts that are the same every time, and some parts that will contain variables that we can substitute in. The <code class="language-plaintext highlighter-rouge">render_template</code> function in the Flask library will allow us to use templates and plug in variables like ``.</li>
  <li data-marker="*">[10:35] We can generate a random number, for example, and display it each time our page is loaded. We can use <code class="language-plaintext highlighter-rouge">control + c</code> to stop our server, and then restart it, to make sure any changes we make are reloaded. And once we load our page in the browser, we can view its source to make sure that Flask substituted our variable as we expected.</li>
  <li data-marker="*">[13:25] We can add conditions to our templates, with <code class="language-plaintext highlighter-rouge">if ...</code>, so depending on the value of our variables, we can return different content entirely.</li>
  <li data-marker="*">[16:25] We can even write a form that our server can accept, with another route that the form can submit to. Then, in that route, our server can receive and use the form data. We write a form that has a name input, and write a route function that gets the input with <code class="language-plaintext highlighter-rouge">request.args.get()</code>, and returns a template with the input substituted in.</li>
  <li data-marker="*">[21:30] We see an Internal Server Error, and in our terminal we see the error that <code class="language-plaintext highlighter-rouge">request</code> is not defined, and it turns out that we need to import it from Flask. We try again, and see that the GET parameters in the URL changes based on what we submit in the form.</li>
  <li data-marker="*">[24:00] We can add additional logic in our route to handle the case where <code class="language-plaintext highlighter-rouge">name</code> is empty, and return a different template.</li>
  <li data-marker="*">[26:00] It turns out that we can have templates for our templates, since many of our pages might have similar HTML code around its content. We’ll create <code class="language-plaintext highlighter-rouge">layout.html</code>, and add a special block inside the <code class="language-plaintext highlighter-rouge">&lt;body&gt;</code> tag. Then, our other files like <code class="language-plaintext highlighter-rouge">index.html</code> can use the template with <code class="language-plaintext highlighter-rouge">extends "layout.html"</code>, and only have the content block for the <code class="language-plaintext highlighter-rouge">body</code>.</li>
  <li data-marker="*">[30:35] And we can add additional blocks, like for content we would want to have inside a <code class="language-plaintext highlighter-rouge">&lt;style&gt;</code> tag in the page.</li>
  <li data-marker="*">[32:20] We’ll start writing a new application by creating a new folder called <code class="language-plaintext highlighter-rouge">tasks</code>, and creating an <code class="language-plaintext highlighter-rouge">application.py</code> file. Inside, we’ll create routes for <code class="language-plaintext highlighter-rouge">/</code> to list tasks and <code class="language-plaintext highlighter-rouge">/add</code> to add a new task. We’ll create a <code class="language-plaintext highlighter-rouge">templates</code> folder with a <code class="language-plaintext highlighter-rouge">layout.html</code> before, a <code class="language-plaintext highlighter-rouge">tasks.html</code> showing a list of items, and a <code class="language-plaintext highlighter-rouge">add.html</code> that includes a simple form. We’ll have our routes render each of these templates, and set our form to use a new method, <code class="language-plaintext highlighter-rouge">POST</code>, to send the form’s data back to the <code class="language-plaintext highlighter-rouge">/add</code> route. Our <code class="language-plaintext highlighter-rouge">add()</code> function can then either display the form for a <code class="language-plaintext highlighter-rouge">GET</code> request, or create a new task for a <code class="language-plaintext highlighter-rouge">POST</code> request.</li>
  <li data-marker="*">[42:30] We can create a global variable, <code class="language-plaintext highlighter-rouge">todos</code>, to store a list of task names that we can display later. In our <code class="language-plaintext highlighter-rouge">add()</code> function, if we get a <code class="language-plaintext highlighter-rouge">POST</code> request with some data, we’ll add the new task name to our list on the server, and redirect back to the default route, which will show a list.</li>
  <li data-marker="*">[44:15] And in our <code class="language-plaintext highlighter-rouge">tasks.html</code> template, we can loop over our <code class="language-plaintext highlighter-rouge">todos</code> list variable with <code class="language-plaintext highlighter-rouge">for todo in todos</code>, and create a <code class="language-plaintext highlighter-rouge">&lt;li&gt;</code> element with the contents set to each item.</li>
  <li data-marker="*">[48:00] We can also make sure that the task name is not empty, by adding some JavaScript code that only enables the submit button if the input field’s value is not empty. Otherwise, we disable the submit button. We do this by adding an event handler to listen to the <code class="language-plaintext highlighter-rouge">onkeyup</code> event for our <code class="language-plaintext highlighter-rouge">task</code> input, which is triggered by the browser every time the user presses a key and releases it.</li>
  <li data-marker="*">[52:40] But our task list goes away when we stop and start our web server, since we initialize our <code class="language-plaintext highlighter-rouge">todos</code> variable to an empty list each time. Next, we’ll use a database with SQL to store and modify data.</li>
</ul></details>

<details><summary>Databases</summary><div class="border embed-responsive embed-responsive-16by9" data-video=""><iframe allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="" class="embed-responsive-item" src="https://www.youtube.com/embed/zdH1PnWxSpA?modestbranding=0&amp;rel=0&amp;showinfo=0"></iframe></div>

<ul>
  <li data-marker="*">So far, we’ve learned how to write a server that can respond with webpages that are the same for every user. But there are websites where we can log in, and it will show us information specific to us.</li>
  <li data-marker="*">Recall that cookies are small files that websites ask our browser to store on our computer, with some kind of identifier that our browser shows the website the next time we go there, so the website knows who we are. This allows our server to have sessions, or data for users’ interactions with a website, specific to each of them.</li>
  <li data-marker="*">[1:20] We’ll look at the task list application we made last time. Since our task list was stored in a global variable in our server application, everyone who visits our page will see the same list.</li>
  <li data-marker="*">[2:40] To solve this, we can use sessions from Flask, by importing and initializing their implementation. By doing so, our <code class="language-plaintext highlighter-rouge">tasks()</code> function can look in the global <code class="language-plaintext highlighter-rouge">session</code> variable, and read, set, or update a <code class="language-plaintext highlighter-rouge">todos</code> key within it. Flask will take care of making sure that the global <code class="language-plaintext highlighter-rouge">session</code> variable is actually specific to the user who made that request, by storing and checking some cookies.</li>
  <li data-marker="*">[7:30] If we want to store more complex data, it would make more sense to use a database instead of session objects. So we’ll create a new application to store registration information, like names and emails.</li>
  <li data-marker="*">[9:25] We’ll make a new empty file, <code class="language-plaintext highlighter-rouge">lecture.db</code>, and run <code class="language-plaintext highlighter-rouge">sqlite3 lecture.db</code> to create a table and set column names and types for the data we think we’ll need.</li>
  <li data-marker="*">[11:00] In <code class="language-plaintext highlighter-rouge">sqlite3</code>, we can run queries to select or insert into the table to check that everything works. In our new Flask application, we’ll import the SQL library from CS50 so we can work with our database more easily, and establish a connection to our <code class="language-plaintext highlighter-rouge">lecture.db</code> file. In our <code class="language-plaintext highlighter-rouge">/</code> route, we can run a <code class="language-plaintext highlighter-rouge">SELECT</code> query to get the rows from our <code class="language-plaintext highlighter-rouge">registrants</code> table, and pass them into our template. Our template will in turn iterate over each row, and generate an <code class="language-plaintext highlighter-rouge">&lt;li&gt;</code> item with the values of each column in each row.</li>
  <li data-marker="*">[17:35] Once we have our index route, we can add more rows to our table with the <code class="language-plaintext highlighter-rouge">sqlite3</code> prompt, and see our server return the new data.</li>
  <li data-marker="*">[18:05] We can add a new route to our application that will insert new data, too. In our <code class="language-plaintext highlighter-rouge">register()</code> function, we can return a <code class="language-plaintext highlighter-rouge">register.html</code> file with a form that has the inputs we need, and ensure that the form submits to our <code class="language-plaintext highlighter-rouge">register</code> route with the <code class="language-plaintext highlighter-rouge">POST</code> method. Then, in our <code class="language-plaintext highlighter-rouge">register</code> route, we can check for a <code class="language-plaintext highlighter-rouge">POST</code> request, insert the data from the request into our table, and redirect to the main route. In our SQL query, we’ll be careful to substitute our variables safely with the <code class="language-plaintext highlighter-rouge">db.execute</code> function, instead of combining the strings ourselves, to avoid SQL injection attacks.</li>
  <li data-marker="*">[23:05] We’ll try out our application, and everything seems to be working as we expect. To improve the design of our server’s code, we’ll factor out some common template code into <code class="language-plaintext highlighter-rouge">layout.html</code>, and create an <code class="language-plaintext highlighter-rouge">apology.html</code> page where we’ll tell the user an error message if something in their form is blank.</li>
  <li data-marker="*">[28:40] Now we can write Flask applications to read and store data in a database, saving our data efficiently for the long term.</li>
</ul></details>

<details><summary>Finance</summary><div class="border embed-responsive embed-responsive-16by9" data-video=""><iframe allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="" class="embed-responsive-item" src="https://www.youtube.com/embed/kAvCTffbH04?modestbranding=0&amp;rel=0&amp;showinfo=0"></iframe></div>

<ul>
  <li data-marker="*">We’ll take the concepts we’ve seen to create CS50 Finance, a virtual stock trading website with an account for users to register for, the ability to get quotes for shares of stocks and to virtually buy or sell them. We’ll also have a history page for each account to see what we’ve done in the past.</li>
  <li data-marker="*">[2:45] We look at the distribution code for CS50 Finance, or the code that we’ll all start off with. We have an <code class="language-plaintext highlighter-rouge">application.py</code> file that our Flask app will run, with various configuration options, a connection to a database file <code class="language-plaintext highlighter-rouge">finance.db</code>, and routes for . This follows the MVC, Model-View-Controller, pattern, which generally separates the concerns of data and how that’s stored (our database), the views that display some amount of data (our templates), and controllers that control the logic of what is displayed when (our <code class="language-plaintext highlighter-rouge">application.py</code> routes).</li>
  <li data-marker="*">[4:45] Since we’re using a third-party API, or Application Programming Interface, some code that someone else wrote designed for us to use, we’ll also need an API key to get stock information.</li>
  <li data-marker="*">[5:30] Notice that our routes also have a <code class="language-plaintext highlighter-rouge">@login_required</code> decorator, or extra attribute in Python to indicate that the function should behave differently. Flask allows us to automatically redirect users to a login page, and we have the login functionality implemented in our distribution code too. The <code class="language-plaintext highlighter-rouge">/login</code> route checks whether a matching user and password exists in our database (for a <code class="language-plaintext highlighter-rouge">POST</code> method, as from the login form), or displays the login form for a <code class="language-plaintext highlighter-rouge">GET</code> method. And in our database, instead of storing the user’s raw password, which is more insecure since hackers might use them against other websites, we store the hash of their password which is sufficient for verification, but difficult from which to recover the original password.</li>
  <li data-marker="*">[14:30] After the <code class="language-plaintext highlighter-rouge">login</code> route we have <code class="language-plaintext highlighter-rouge">logout</code>, which just clears the session, and we have <code class="language-plaintext highlighter-rouge">quote</code>, <code class="language-plaintext highlighter-rouge">register</code>, and <code class="language-plaintext highlighter-rouge">sell</code> routes left to implement.</li>
  <li data-marker="*">[15:10] We’ll implement:
    <ul>
      <li data-marker="*"><code class="language-plaintext highlighter-rouge">register</code> so we can register for a new account</li>
      <li data-marker="*"><code class="language-plaintext highlighter-rouge">quote</code> so we can get a price quote for a stock</li>
      <li data-marker="*"><code class="language-plaintext highlighter-rouge">buy</code> to buy some shares of a stock</li>
      <li data-marker="*"><code class="language-plaintext highlighter-rouge">index</code> to show the stocks in our account</li>
      <li data-marker="*"><code class="language-plaintext highlighter-rouge">sell</code> to sell some shares of a stock</li>
      <li data-marker="*"><code class="language-plaintext highlighter-rouge">history</code> to show transactions in the past</li>
      <li data-marker="*">and a personal feature of our choice</li>
    </ul>
  </li>
  <li data-marker="*">[15:55] We talk about the requirements for each of these routes, and how they might be implemented with conditions based on the request’s method, and either display forms or perform some action after validating the request.</li>
  <li data-marker="*">[20:50] We have an existing <code class="language-plaintext highlighter-rouge">finance.db</code> database, and we can use <code class="language-plaintext highlighter-rouge">sqlite3 finance.db</code> to run queries that add columns or tables that we might want to use to store additional data to support our routes.</li>
  <li data-marker="*">[23:00] <code class="language-plaintext highlighter-rouge">index</code> will query our database for a user’s stocks and their cash balance, along with using an API to get the current price of each and displaying all this data with a template. <code class="language-plaintext highlighter-rouge">sell</code>, too, should have validation and update our data in the database.</li>
  <li data-marker="*">[25:25] Finally, we might need another table (in our database) to support our <code class="language-plaintext highlighter-rouge">history</code> page, and display the data for each user’s transactions in a table (in our template).</li>
  <li data-marker="*">[26:25] And we’ll need to add a personal touch, whether that’s allowing users to change their password, add cash, or additional features.</li>
</ul></details>

<details><summary>Conclusion</summary><div class="border embed-responsive embed-responsive-16by9" data-video=""><iframe allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="" class="embed-responsive-item" src="https://www.youtube.com/embed/I-e5Jzq0yA8?modestbranding=0&amp;rel=0&amp;showinfo=0"></iframe></div>

<ul>
  <li data-marker="*">In this track, we learned about how computers communicate over an internet, structured web pages with HTML and styled them with CSS, and added some interactivity with JavaScript. Then we learned how to write a web server application with Flask, that can dynamically generate web pages and use a database to read and write data.</li>
</ul></details>

## Shorts
<ul>
  <li data-marker="*"><a href="https://www.youtube.com/watch?v=dQcBs4S-wEQw">Ajax</a></li>
  <li data-marker="*"><a href="https://www.youtube.com/watch?v=X0dwkDh8kwA">Flask</a></li>
</ul>

## References
<ul>
  <li data-marker="*"><a href="ap/assets/pdfs/ajax.pdf">Ajax</a></li>
  <li data-marker="*"><a href="ap/assets/pdfs/mvc.pdf">MVC</a></li>
  <li data-marker="*"><a href="ap/assets/pdfs/python_for_web_programming.pdf">Python for Web Programming</a></li>
</ul>

## Problems
* [Finance](https://cs50.harvard.edu/ap/2021/curriculum/x/tracks/web/finance/)

### Past problems
<ul>
  <li data-marker="*"><a href="https://docs.cs50.net/2019/ap/problems/similarities/similarities.html">Similarities</a></li>
  <li data-marker="*"><a href="https://docs.cs50.net/2019/ap/problems/survey/survey.html">Survey</a></li>
</ul>